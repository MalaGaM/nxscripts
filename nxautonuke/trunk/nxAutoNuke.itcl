################################################################################
# nxAutoNuke - Auto-Nuke Banned, Empty, Incomplete, IMDB, and MP3 Releases     #
################################################################################
# Author  : neoxed                                                             #
# Date    : 01-31-2005                                                         #
# Version : 1.1.3 (rev 041)                                                    #
################################################################################

#### AutoNuke Settings #####################################
#
# - User and group to use for auto-nuking (must be valid!).
# - Nuke the whole release or only the violating sub-directory.
#
set anuke(UserName)     "ioFTPD"
set anuke(GroupName)    "ioFTPD"
set anuke(Release)      True
#
# - Bad and missing file extension (created by the zipscript).
# - Most zipscripts don't create .missing files for non-SFV releases (i.e. ZIPs);
#   we can overcome this problem, somewhat, by additionally checking for .bad files.
#
set anuke(BadExt)       "*.bad"
set anuke(MissingExt)   "*.missing"
#
# - Maximum age of directories to check (minutes).
# - Exempt certain releases from being checked (case insensitive).
# - Prefix for nuked releases (no wild-cards and case sensitive).
#
set anuke(MaximumAge)   1440
set anuke(Exempts)      {(incomplete)-* *dirfix* *dir[._]fix* *[._]fix[._]* *nfofix* *nfo[._]fix* *nfoupdate* *nfo[._]update* *samplefix* *sample[._]fix*}
set anuke(Prefix)       {[NUKED]-}
#
# - Display the uploaders for auto-nuke warning announcements.
# - Format of the uploaders list, cookies: %b = bold, %c = color, %u = underline, %(user), and %(group).
#
set anuke(WarnUsers)    True
set anuke(UserFormat)   "%b%(user)%b/%(group)"
set anuke(UserSplit)    ", "

#### AutoNuke Templates ####################################
#
# - Zipscript tag templates used for IMDB and MP3 checks.
# - Regular expression patterns are used to parse the tag data.
#
# - dZSbot IMDB: [IMDB] - Action (2004) - 2.7 of 10 - [IMDB]
# set anuke(ImdbMatch) {^\[IMDB\] - (.+) \((\d+)\) - ([\d\.]+) of 10 - \[IMDB\]$}
# set anuke(ImdbOrder) {genre year rating}
#
# - CalaZS MP3: [SITE] - ( 77.0MB 8F - COMPLETE - Death Metal 2004 ) - [SITE]
# set anuke(MP3Match) {^\[.*\] - \( .* - COMPLETE - (.+) (\d+) \) - \[.*\]$}
# set anuke(MP3Order) {genre year}
#
# - ioBanana IMDB: [4.0% Incomplete with 2F]-[imdbinfo - Action Adventure Animation Fantasy Family (2004) - 2.7 (520 votes)]
# set anuke(ImdbMatch) {^\[.*\]-\[imdbinfo - (.+) \((\d+)\) - ([\d\.]+) (.* votes)\]$}
# set anuke(ImdbOrder) {genre year rating}
#
# - ioBanana MP3: [100% Complete]-[8F @ 77.0MB at 4261Kbps]-[mp3info - Death Metal (2004) @ 256-kbps]
# set anuke(MP3Match) {^\[.*\]-\[.*\]-\[mp3info - (.+) \((\d+)\) @ .*\]$}
# set anuke(MP3Order) {genre year}
#
set anuke(ImdbMatch)    {^\[IMDB\] - (.+) \((\d+)\) - ([\d\.]+) of 10 - \[IMDB\]$}
set anuke(ImdbOrder)    {genre year rating}
set anuke(MP3Match)     {^\[.*\] - \( .* - COMPLETE - (.+) (\d+) \) - \[.*\]$}
set anuke(MP3Order)     {genre year}
#
# - The approve tag format, to exempt approved releases.
#
set anuke(ApproveTag)   {approved?by?*}

#### AutoNuke Reasons ######################################
#
# - General Cookies:
#   %(minutes)    - The remaining minutes until the release is nuked.
#
# - Special Cookies:
#   Allowed:
#     %(banned)   - The group's name which wasn't in the allow list.
#   Banned:
#     %(banned)   - The banned string which matched the release name.
#   Disks:
#     %(disks)    - Number of CDs/Disks the release had.
#     %(maxdisks) - The maximum number of disks allowed in that section.
#   IMDB:
#     %(type)     - The type of ban (genre/rating/year).
#     %(banned)   - The banned value (i.e. the release's genre, rating, or year).
#   MP3:
#     %(type)     - The type of ban (genre/year).
#     %(banned)   - The banned value (i.e. the release's genre or year).
#   Type:
#     %(banned)   - The banned keyword (bootleg, live, etc.).
#
set anuke(ReasonAllowed) "the.group.%(banned).is.not.allowed"
set anuke(ReasonBanned)   "banned.release.%(banned)"
set anuke(ReasonDisks)   "maximum.of.%(maxdisks).disks"
set anuke(ReasonEmpty)   "empty.after.%(minutes).minutes"
set anuke(ReasonImdb)    "banned.%(type).%(banned)"
set anuke(ReasonInc)     "incomplete.after.%(minutes).minutes"
set anuke(ReasonMP3)     "banned.%(type).%(banned)"
set anuke(ReasonType)    "banned.type.%(banned)"

#### AutoNuke Sections #####################################
#
# - Here you define the paths and type of auto-nuke checks to perform.
#   <virtual path> <day offset> {
#       {<check type>|<check settings>|<nuke multiplier>|<warn time>|<nuke time>}
#       ...
#   }
# - The 'virtual path' is the path to check, which may contain date cookies.
# - Available date cookies: %d - Day, %W - Week, %m - Month, %y - Year (04), %Y - Year with century (2004).
# - The 'day offset' is the offset of the current day (-1 for yesterday, 0 for today, 1 for tomorrow, etc.).
# - The 'warn time' and 'nuke time' are for how long to wait after the directory was created (in minutes).
#
# - Check Types:
#   allowed:
#     - Check for allowed release groups, nuke groups which are not allowed.
#     - Check settings: allowed groups, you may use wild-cards.
#   banned:
#     - Check for banned matches in the release name.
#     - Check settings: banned strings, you may use wild-cards.
#   disks:
#     - Enfore maximum number of disks per section (CDs, Disks, and DVDs).
#     - Check settings: max number of disks, anything larger then this will be nuked.
#   empty:
#     - Nuke empty releases or sub-directories, with no files.
#     - Check settings: not used for empty checks.
#   imdb:
#     - Nuke banned genres, low ratings, or unaccepted years.
#     - Check settings: genre:<banned genre> rating:<minimum rating> year:<allowed year>
#   incomplete:
#     - Nuke incomplete releases or sub-directories (checks for ".bad" or ".missing" files).
#     - Check settings: not used for incomplete checks.
#   mp3:
#     - Nuke banned genres or unaccepted years.
#     - Check settings: genre:<banned genre> year:<allowed year>
#   type:
#     - Check for banned keywords in the release name.
#     - Check settings: banned release keywords, no wild-cards.
#     - This works similar to the "banned" feature, but more efficiently for keywords.
#
set anuke(Sections) {
    "/0DAY/%m%d" 0 {
        {banned|*-A51 *-HS *-TiC *-YAG|10|0|0}
        {empty|Not-Used|3|20|40}
    }
    "/APPS" 0 {
        {disks|4|3|5|20}
        {empty|Not-Used|3|20|40}
        {incomplete|Not-Used|3|20|40}
    }
    "/GAMES" 0 {
        {empty|Not-Used|3|20|40}
        {incomplete|Not-Used|3|20|40}
    }
    "/MP3/%m%d" 0 {
        {incomplete|Not-Used|3|20|40}
        {empty|Not-Used|3|20|40}
        {mp3|genre:*rap* genre:*punk* year:200[0-6]|5|20|40}
        {type|cable dab demo dvb mixtape radio sample sat tape|3|20|40}
    }
    "/MP3/%m%d" -1 {
        {incomplete|Not-Used|3|20|40}
        {empty|Not-Used|3|20|40}
        {mp3|genre:*rap* genre:*punk* year:200[0-6]|5|20|40}
        {type|cable dab demo dvb mixtape radio sample sat tape|3|20|40}
    }
    "/SVCD" 0 {
        {disks|4|3|5|20}
        {empty|Not-Used|3|20|40}
        {imdb|genre:*documentary* genre:*romance* rating:5 year:200[2-6]|3|5|20}
        {incomplete|Not-Used|3|20|40}
    }
    "/VCD" 0 {
        {disks|3|3|5|20}
        {empty|Not-Used|3|20|40}
        {imdb|genre:*documentary* genre:*romance* rating:4 year:200[2-6]|3|5|20}
    }
    "/XXX" 0 {
        {allowed|LonelyWankers JackOffs MasterDebators|3|5|20}
        {disks|3|3|5|20}
        {empty|Not-Used|3|20|40}
    }
}

#### End of Settings #######################################

# Load Libraries
######################################################################

if {[catch {source [file join [file dirname [info script]] "nxLib.itcl"]} ErrorMsg]} {
    iputs "Error loading nxLib: $ErrorMsg"; return 1
}
if {[catch {load "tclsqlite3.dll" Tclsqlite3} ErrorMsg]} {
    iputs "Error loading SQLite: $ErrorMsg"; return 1
}

# Nuke Procedures
######################################################################

proc ANukeCredits {UserName Multi Size Files Stats CreditSection StatsSection} {
    set CreditSection [expr {$CreditSection + 1}]
    set StatsSection [expr {$StatsSection * 3 + 1}]
    set GroupName "NoGroup"
    set NewUserFile ""

    if {[userfile open $UserName] == 0} {
        userfile lock
        set UserFile [split [userfile bin2ascii] "\r\n"]
        foreach UserLine $UserFile {
            set LineType [string tolower [lindex $UserLine 0]]
            if {[string equal "credits" $LineType]} {
                set OldCredits [lindex $UserLine $CreditSection]
            } elseif {[string equal "groups" $LineType]} {
                set GroupName [GetGroupName [lindex $UserLine 1]]
            } elseif {[string equal "ratio" $LineType]} {
                set Ratio [lindex $UserLine $CreditSection]
            }
        }

        ## Change credits if the user is not leech
        if {$Ratio != 0} {
            set DiffCredits [expr {(wide($Size) * $Ratio) + (wide($Size) * ($Multi - 1))}]
            set NewCredits [expr {wide($OldCredits) - wide($DiffCredits)}]
        } else {
            set DiffCredits 0
            set NewCredits $OldCredits
        }
        foreach UserLine $UserFile {
            set LineType [string tolower [lindex $UserLine 0]]
            if {[lsearch -exact {allup dayup monthup wkup} $LineType] != -1} {
                set NewFiles [expr {wide([lindex $UserLine $StatsSection]) - $Files}]
                set NewStats [expr {wide([lindex $UserLine [expr {$StatsSection + 1}]]) - wide($Stats)}]
                set UserLine [lreplace $UserLine $StatsSection [expr {$StatsSection + 1}] $NewFiles $NewStats]
            } elseif {[string equal "credits" $LineType]} {
                set UserLine [lreplace $UserLine $CreditSection $CreditSection $NewCredits]
            }
            append NewUserFile $UserLine "\r\n"
        }
        userfile ascii2bin $NewUserFile
        userfile unlock
    }
    return [list $GroupName $Ratio $OldCredits $NewCredits $DiffCredits]
}

proc ANukeName {VirtualPath} {
    set Release [file tail $VirtualPath]
    if {[IsMultiDisk $Release]} {
        set ParentPath [file tail [file dirname $VirtualPath]]
        if {![string equal "" $ParentPath]} {set Release "$ParentPath ($Release)"}
    }
    return $Release
}

proc ANukeInternal {RealPath VirtualPath NukerUser NukerGroup Multi Reason} {
    global misc nuke
    if {![file isdirectory $RealPath]} {
        ErrorLog ANuker "Unable to nuke \"$VirtualPath\": directory does not exist."
        return 0
    } elseif {![string is digit -strict $Multi]} {
        ErrorLog ANuker "Unable to nuke \"$VirtualPath\": invalid multiplier value ($Multi)."
        return 0
    }

    set DiskCount 0; set Files 0; set TotalSize 0
    set TimeStamp [clock seconds]
    set Release [ANukeName $VirtualPath]
    set ParentPath [file dirname $RealPath]
    ListAssign [GetCreditsAndStats $VirtualPath] CreditSection StatsSection

    ## Count CDs/Discs/DVDs
    foreach ListItem [glob -nocomplain -types d -directory $RealPath "*"] {
        if {[IsMultiDisk $ListItem]} {incr DiskCount}
    }

    ## Count files and total size
    GetDirList $RealPath dirlist ".ioFTPD*"
    foreach ListItem $dirlist(FileList) {
        incr Files; set FileSize [file size $ListItem]
        set TotalSize [expr {wide($TotalSize) + wide($FileSize)}]
        catch {lindex [vfs read $ListItem] 0} UserID
        if {[set NukeeUser [resolve uid $UserID]] != ""} {
            ## Increase file Count
            if {[info exists nukefiles($NukeeUser)]} {
                incr nukefiles($NukeeUser)
            } else {set nukefiles($NukeeUser) 1}

            ## Add total size
            if {[info exists nukesize($NukeeUser)]} {
                set nukesize($NukeeUser) [expr {wide($nukesize($NukeeUser)) + wide($FileSize)}]
            } else {set nukesize($NukeeUser) $FileSize}
        }
    }
    set TotalSize [expr {wide($TotalSize) / 1024}]

    ## Check if Release is an empty nuke (less then 5KB)
    if {$TotalSize < 5 || ![array exists nukesize]} {
        unset -nocomplain nukefiles nukesize
        set EmptyNuke 1
        catch {lindex [vfs read $RealPath] 0} UserID
        if {[set NukeeUser [resolve uid $UserID]] != ""} {
            set nukefiles($NukeeUser) 0
            set nukesize($NukeeUser) [expr {wide($nuke(EmptyNuke)) * 1024 * 1024}]
        } else {
            ErrorLog ANuker "Unable to nuke \"$VirtualPath\": could not find directory owner."
            return 0
        }
    } else {set EmptyNuke 0}

    ## Change the credits and stats of nukees
    set NukeeLog ""
    foreach NukeeUser [lsort -ascii [array names nukesize]] {
        set NukeCredits [expr {wide($nukesize($NukeeUser)) / 1024}]
        set NukeStats [expr {$EmptyNuke ? 0 : $NukeCredits}]
        set Result [ANukeCredits $NukeeUser $Multi $NukeCredits $nukefiles($NukeeUser) $NukeStats $CreditSection $StatsSection]
        foreach {NukeeGroup Ratio OldCredits NewCredits DiffCredits} $Result {break}
        lappend NukeeLog [list $NukeeUser $NukeeGroup $NukeStats]
    }
    ## Double join the list (since there's a sublist)
    set NukeeLog [join [join [lsort -decreasing -integer -index 2 $NukeeLog]]]

    ## Create nuke tag
    set ReMap [list %(user) $NukerUser %(group) $NukerGroup %(multi) $Multi %(reason) $Reason]
    set NukeTag [file join $RealPath [string map $ReMap $nuke(InfoTag)]]
    CreateTag $NukeTag [resolve user $NukerUser] [resolve group $NukerGroup] 555
    RemoveParentLinks $RealPath $VirtualPath

    ## Record nuke info
    set NukeRecord [file join $RealPath ".ioFTPD.nxNuke"]
    catch {file attributes $NukeRecord -hidden 0}
    if {![catch {set Handle [open $NukeRecord w]} ErrorMsg]} {
        puts $Handle "NUKE|$NukerUser|$NukerGroup|$Multi|$Reason"
        close $Handle
    } else {ErrorLog ANukeRecord $ErrorMsg}
    catch {file attributes $NukeRecord -hidden 1}

    ## Rename nuke directory
    set NewName "$nuke(Prefix)[file tail $VirtualPath]"
    set NewPath [file join $ParentPath $NewName]
    catch {vfs flush $RealPath}
    if {![string equal -nocase $RealPath $NewPath]} {
        ## Chmod the directory to 000 so users can't re-enter it
        catch {vfs read $RealPath} VfsOwner
        ListAssign $VfsOwner UserID GroupID
        if {![string is digit -strict $UserID]} {set UserID [lindex $misc(DirOwner) 0]}
        if {![string is digit -strict $GroupID]} {set GroupID [lindex $misc(DirOwner) 1]}
        catch {vfs write $RealPath $UserID $GroupID 000}
        KickUsers [file join $VirtualPath "*"]
        if {[catch {file rename -force -- $RealPath $NewPath} ErrorMsg]} {
            ErrorLog ANukeRename $ErrorMsg
        }
    }

    ## Chmod directories
    GetDirList $NewPath dirlist ".ioFTPD*"
    foreach ListItem $dirlist(DirList) {
        catch {vfs read $ListItem} VfsOwner
        ListAssign $VfsOwner UserID GroupID
        if {![string is digit -strict $UserID]} {set UserID [lindex $misc(DirOwner) 0]}
        if {![string is digit -strict $GroupID]} {set GroupID [lindex $misc(DirOwner) 1]}
        catch {vfs write $ListItem $UserID $GroupID 555}
    }
    catch {vfs flush $ParentPath}
    if {[IsTrue $misc(dZSbotLogging)]} {
        foreach {NukeeUser NukeeGroup Amount} $NukeeLog {
            set Amount [format "%.2f" [expr {double($Amount) / 1024.0}]]
            putlog "NUKE: \"$VirtualPath\" \"$NukerUser@$NukerGroup\" \"$NukeeUser@$NukeeGroup\" \"$Multi $Amount\" \"$Reason\""
        }
    } else {
        putlog "NUKE: \"$VirtualPath\" \"$NukerUser\" \"$NukerGroup\" \"$Multi\" \"$Reason\" \"$Files\" \"$TotalSize\" \"$DiskCount\" \"$NukeeLog\""
    }
    set DbFile [file join $misc(DataPath) "Nukes.db"]
    if {![catch {sqlite3 NukeDb $DbFile} ErrorMsg]} {
        NukeDb eval {INSERT INTO Nukes (TimeStamp,UserName,GroupName,Status,Release,Reason,Multi,Files,Size,Nukees) VALUES($TimeStamp,$user,$group,$NukeStatus,$Release,$Reason,$Multi,$Files,$TotalSize,$NukeeLog)}
        NukeDb close
    } else {ErrorLog ANukeDb $ErrorMsg}
    return 1
}

# AutoNuke Procedures
######################################################################

proc ANukeAllowed {Patterns ReleaseName TargetValue} {
    upvar $TargetValue GroupName
    if {[set GroupPos [string last "-" $ReleaseName]] == -1} {return 0}
    set GroupName [string range $ReleaseName [incr GroupPos] end]
    foreach Pattern $Patterns {
        if {[string match -nocase $Pattern $GroupName]} {
            set BanValue $Pattern; return 0
        }
    }
    return 1
}

proc ANukeBanned {Patterns ReleaseName TargetValue} {
    upvar $TargetValue BanValue
    foreach Pattern $Patterns {
        if {[string match -nocase $Pattern $ReleaseName]} {
            set BanValue $Pattern; return 1
        }
    }
    return 0
}

proc ANukeEmpty {RealPath} {
    foreach FileName [glob -nocomplain -types f -directory $RealPath "*"] {
        if {![string equal -nocase -length 7 ".ioFTPD" [file tail $FileName]]} {return 0}
    }
    return 1
}

proc ANukeInc {RealPath} {
    global anuke
    foreach ListItem [glob -nocomplain -types f -directory $RealPath "*"] {
        set FileName [file tail $ListItem]
        if {[string match -nocase $anuke(BadExt) $FileName] || [string match -nocase $anuke(MissingExt) $FileName]} {return 1}
    }
    return 0
}

proc ANukeToList {CheckSettings} {
    set CheckList ""
    foreach ListItem $CheckSettings {
        foreach {Name Value} [split $ListItem ":"] {break}
        lappend CheckList [string tolower $Name] $Value
    }
    return $CheckList
}

proc ANukeIMDB {TagList CheckList TargetType TargetValue} {
    global anuke
    upvar $TargetType BanType $TargetValue BanValue

    set FoundMatch 0; set genre ""; set rating ""; set year ""
    foreach TagName $TagList {
        set ReMatch [regexp -inline -nocase -- $anuke(ImdbMatch) [file tail $TagName]]
        if {[llength $ReMatch]} {
            foreach $anuke(ImdbOrder) [lrange $ReMatch 1 end] {break}
            set FoundMatch 1; break
        }
    }
    if {!$FoundMatch} {return 0}

    foreach {BanType BanMatch} $CheckList {
        switch -exact -- $BanType {
            "genre" {
                if {[string match -nocase $BanMatch $genre]} {
                    set BanValue $genre; return 1
                }
            }
            "rating" {
                if {[string is double -strict $rating] && $rating < $BanMatch} {
                    set BanValue $rating; return 1
                }
            }
            "year" {
                if {$year != "" && ![string match -nocase $BanMatch $year]} {
                    set BanValue $year; return 1
                }
            }
        }
    }
    return 0
}

proc ANukeMP3 {TagList CheckList TargetType TargetValue} {
    global anuke
    upvar $TargetType BanType $TargetValue BanValue

    set FoundMatch 0; set genre ""; set year ""
    foreach TagName $TagList {
        set ReMatch [regexp -inline -nocase -- $anuke(MP3Match) [file tail $TagName]]
        if {[llength $ReMatch]} {
            foreach $anuke(MP3Order) [lrange $ReMatch 1 end] {break}
            set FoundMatch 1; break
        }
    }
    if {!$FoundMatch} {return 0}

    foreach {BanType BanMatch} $CheckList {
        switch -exact -- $BanType {
            "genre" {
                if {[string match -nocase $BanMatch $genre]} {
                    set BanValue $genre; return 1
                }
            }
            "year" {
                if {$year != "" && ![string match -nocase $BanMatch $year]} {
                    set BanValue $year; return 1
                }
            }
        }
    }
    return 0
}

proc ANukeType {TypeList ReleaseName TargetType} {
    upvar $TargetType BanType
    ## Remove the group name from the release
    if {[set GroupPos [string last "-" $ReleaseName]] != -1} {
        set ReleaseName [string range $ReleaseName 0 [incr GroupPos -1]]
    }
    set ReleaseSplit [string tolower [split $ReleaseName "()-._"]]

    ## Match types
    foreach TypeName $TypeList {
        if {[lsearch -exact $ReleaseSplit $TypeName] != -1} {
            set BanType $TypeName; return 1
        }
    }
	return 0
}

proc ANukeCheck {RealPath VirtualPath} {
    global anuke
    upvar check check NukedList NukedList WarnedList WarnedList

    ## Skip the release if it was already nuked
    set RealPathLow [string tolower $RealPath]
    if {[lsearch -exact $NukedList $RealPathLow] != -1} {return}
    set NukeSecs [expr {$check(NukeMins) * 60}]
    set WarnSecs [expr {$check(WarnMins) * 60}]

    if {$check(DirAge) >= $NukeSecs} {
        ## Nuke the release
        lappend check(CookieMap) %(minutes) $check(NukeMins)
        set check(Reason) [StripChars [string map $check(CookieMap) $check(Reason)]]

        if {[IsTrue $anuke(Release)] && [IsMultiDisk $VirtualPath]} {
            set RealPath [file dirname $RealPath]
            set VirtualPath [file dirname $VirtualPath]
        }

        LinePuts "Nuking: [ANukeName $VirtualPath] - $check(Reason)"
        if {![ANukeInternal $RealPath $VirtualPath $anuke(UserName) $anuke(GroupName) $check(Multi) $check(Reason)]} {
            LinePuts "Encounted an error nuking the release, check nxError.log for details."
        }
        lappend NukedList $RealPathLow
    } elseif {$check(DirAge) >= $WarnSecs && [lsearch -exact $WarnedList $RealPathLow] == -1} {
        ## Obtain a list of nuked users
        if {[IsTrue $anuke(WarnUsers)]} {
            set UserList [ANukeUsers $RealPath]
        } else {
            set UserList "Disabled"
        }

        ## Log the warning
        lappend check(CookieMap) %(minutes) $check(WarnMins)
        set check(Reason) [StripChars [string map $check(CookieMap) $check(Reason)]]

        LinePuts "Warning: [ANukeName $VirtualPath] - $check(Reason)"
        putlog "$check(WarningLog) \"$check(DirAge)\" \"[expr {$NukeSecs - $check(DirAge)}]\" \"$NukeSecs\" \"$check(Multi)\" \"$UserList\""
        lappend WarnedList $RealPathLow
    }
    return
}

proc ANukeFindTag {RealPath {TagTemplate "*"}} {
    set TagTemplate [string map {\[ \\\[ \] \\\] \{ \\\{ \} \\\}} $TagTemplate]
    return [glob -nocomplain -types d -directory $RealPath $TagTemplate]
}

proc ANukeUsers {RealPath} {
    global anuke
    GetDirList $RealPath dirlist ".ioFTPD*"
    foreach ListItem $dirlist(FileList) {
        if {[file size $ListItem] < 1} {continue}
        catch {vfs read $ListItem} VfsOwner
        ListAssign $VfsOwner UserID GroupID
        if {[set UserName [resolve uid $UserID]] != "" && ![info exists uploader($UserName)]} {
            set uploader($UserName) [GetGroupName $GroupID]
        }
    }
    ## Check if the release is an empty nuke
    if {[array names uploader] == ""} {
        catch {vfs read $RealPath} VfsOwner
        ListAssign $VfsOwner UserID GroupID
        if {[set UserName [resolve uid $UserID]] != ""} {
            set uploader($UserName) [GetGroupName $GroupID]
        } else {return ""}
    }
    ## Format uploaders list
    set FormatList ""
    foreach {UserName GroupName} [array get uploader] {
        set ReMap [list %b \002 %c \003 %u \031 %(user) $UserName %(group) $GroupName]
        lappend FormatList [string map $ReMap $anuke(UserFormat)]
    }
    return [join [lsort -ascii $FormatList] $anuke(UserSplit)]
}

# AutoNuke Main
######################################################################

proc ANukeMain {} {
    global anuke misc user group
    ## A userfile and VFS file will have to be opened so that resolve works under ioFTPD's scheduler
    if {![info exists user] && ![info exists group]} {
        if {[userfile open $misc(MountUser)] != 0} {
            ErrorLog AutoNuke "Error opening the user \"$misc(MountUser)\""; return 1
        } elseif {[mountfile open $misc(MountFile)] != 0} {
            ErrorLog AutoNuke "Error mounting the VFS-file \"$misc(MountFile)\""; return 1
        }
    }
    iputs ".-\[AutoNuke\]-------------------------------------------------------------."
    LinePuts "Checking [expr {[llength $anuke(Sections)] / 3}] auto-nuke sections."
    set NukedList ""; set WarnedList ""
    set anuke(ImdbOrder) [string tolower $anuke(ImdbOrder)]
    set anuke(MP3Order) [string tolower $anuke(MP3Order)]

    ## Timestamp used to format date cookies
    set TimeNow [clock seconds]
    if {[IsTrue $misc(UTC_Time)]} {set TimeNow [ToUTC $TimeNow $misc(TimeZone)]}
    set MaxAge [expr {$anuke(MaximumAge) * 60}]

    foreach {VirtualPath DayOffset NukeChecks} $anuke(Sections) {
        ## Convert date cookies
        set AreaTime [expr {$TimeNow + ($DayOffset * 86400)}]
        set VirtualPath [clock format $AreaTime -format $VirtualPath -gmt 0]
        LinePuts ""; LinePuts "Checking path: $VirtualPath (offset: $DayOffset)"
        set RealPath [resolve pwd $VirtualPath]
        if {![file isdirectory $RealPath]} {
            LinePuts "The directory does not exist, skipping."; continue
        }

        ## Check each auto-nuke type
        foreach ConfigLine $NukeChecks {
            if {[llength [set NukeCheck [split $ConfigLine "|"]]] != 5} {
                ErrorLog ANukeConfig "Wrong number of parameters in line: \"$ConfigLine\""; continue
            }
            foreach {CheckType CheckSettings check(Multi) check(WarnMins) check(NukeMins)} $NukeCheck {break}
            set TagType ""; set TagTemplate ""

            ## Validate auto-nuke type
            set CheckType [string tolower $CheckType]
            switch -exact -- $CheckType {
                "banned" - "type" {
                    set CheckSettings [string tolower $CheckSettings]
                }
                "imdb" - "mp3" {
                    set CheckSettings [ANukeToList $CheckSettings]
                }
                "allowed" - "disks" - "empty" - "inc" - "incomplete" {}
                default {
                    ErrorLog ANukeConfig "Invalid auto-nuke type \"$CheckType\" in line: \"$ConfigLine\""; continue
                }
            }
            set SingleDiskCheck [expr {[lsearch -exact "empty incomplete mp3" $CheckType] == -1}]

            foreach ReleasePath [glob -nocomplain -types d -directory $RealPath "*"] {
                set ReleaseName [file tail $ReleasePath]
                ## Remove exempted, old, and approved releases from the list
                if {![string first $anuke(Prefix) $ReleaseName] || [ListMatch $anuke(Exempts) $ReleaseName True] || [ANukeFindTag $ReleasePath $anuke(ApproveTag)] != "" || \
                    [catch {file stat $ReleasePath fstat}] || [set check(DirAge) [expr {[clock seconds] - $fstat(ctime)}]] > $MaxAge} {
                    continue
                }

                ## Find multi-disk directories
                set DoNuke 0; set CheckRealPaths ""; set ReMap ""
                foreach DiskDir [glob -nocomplain -types d -directory $ReleasePath "*"] {
                    if {[string first $anuke(Prefix) $ReleaseName] != 0 && [IsMultiDisk $DiskDir]} {
                        lappend CheckRealPaths $DiskDir
                    }
                }
                if {![llength $CheckRealPaths]} {lappend CheckRealPaths $ReleasePath}
                set CheckRealPath $ReleasePath
                set CheckVirtualPath [file join $VirtualPath $ReleaseName]

                if {$SingleDiskCheck} {
                    ## Release specific checks
                    switch -exact -- $CheckType {
                        "allowed" {
                            if {[ANukeAllowed $CheckSettings $ReleaseName BanMatch]} {
                                set check(Reason) $anuke(ReasonAllowed)
                                set check(CookieMap) [list %(banned) $BanMatch]
                                set check(WarningLog) "ANUKEALLOW: \"$CheckVirtualPath\" \"$BanMatch\""
                                ANukeCheck $CheckRealPath $CheckVirtualPath
                            }
                        }
                        "banned" {
                            if {[ANukeBanned $CheckSettings $ReleaseName BanMatch]} {
                                set check(Reason) $anuke(ReasonBanned)
                                set check(CookieMap) [list %(banned) $BanMatch]
                                set check(WarningLog) "ANUKEBAN: \"$CheckVirtualPath\" \"$BanMatch\""
                                ANukeCheck $CheckRealPath $CheckVirtualPath
                            }
                        }
                        "disks" {
                            if {[set DiskCount [llength $CheckRealPaths]] > $CheckSettings} {
                                set check(Reason) $anuke(ReasonDisks)
                                set check(CookieMap) [list %(disks) $DiskCount %(maxdisks) $CheckSettings]
                                set check(WarningLog) "ANUKECDS: \"$CheckVirtualPath\" \"$DiskCount\" \"$CheckSettings\""
                                ANukeCheck $CheckRealPath $CheckVirtualPath
                            }
                        }
                        "imdb" {
                            if {[set TagList [ANukeFindTag $CheckRealPath]] != "" && [ANukeIMDB $TagList $CheckSettings BanType BanValue]} {
                                set check(Reason) $anuke(ReasonImdb)
                                set check(CookieMap) [list %(type) $BanType %(banned) $BanValue]
                                set check(WarningLog) "ANUKEIMDB: \"$CheckVirtualPath\" \"$BanType\" \"$BanValue\""
                                ANukeCheck $CheckRealPath $CheckVirtualPath
                            }
                        }
                        "type" {
                            if {[ANukeType $CheckSettings $ReleaseName BanType]} {
                                set check(Reason) $anuke(ReasonType)
                                set check(CookieMap) [list %(banned) $BanType]
                                set check(WarningLog) "ANUKETYPE: \"$CheckVirtualPath\" \"$BanType\""
                                ANukeCheck $CheckRealPath $CheckVirtualPath
                            }
                        }
                    }
                } else {
                    ## Multi-disk specific checks
                    foreach CheckRealPath $CheckRealPaths {
                        if {[IsMultiDisk $CheckRealPath]} {
                            ## Find the age of the disk directory
                            if {[catch {file stat $CheckRealPath fstat}]} {continue}
                            set check(DirAge) [expr {[clock seconds] - $fstat(ctime)}]
                            set CheckVirtualPath [file join $VirtualPath $ReleaseName [file tail $CheckRealPath]]
                        }
                        switch -exact -- $CheckType {
                            "empty" {
                                if {[ANukeEmpty $CheckRealPath]} {
                                    set check(Reason) $anuke(ReasonEmpty)
                                    set check(CookieMap) ""
                                    set check(WarningLog) "ANUKEEMPTY: \"$CheckVirtualPath\""
                                    ANukeCheck $CheckRealPath $CheckVirtualPath
                                }
                            }
                            "inc" - "incomplete" {
                                if {[ANukeInc $CheckRealPath]} {
                                    set check(Reason) $anuke(ReasonInc)
                                    set check(CookieMap) ""
                                    set check(WarningLog) "ANUKEINC: \"$CheckVirtualPath\""
                                    ANukeCheck $CheckRealPath $CheckVirtualPath
                                }
                            }
                            "mp3" {
                                if {[set TagList [ANukeFindTag $CheckRealPath]] != "" && [ANukeMP3 $TagList $CheckSettings BanType BanValue]} {
                                    set check(Reason) $anuke(ReasonMP3)
                                    set check(CookieMap) [list %(type) $BanType %(banned) $BanValue]
                                    set check(WarningLog) "ANUKEMP3: \"$CheckVirtualPath\" \"$BanType\" \"$BanValue\""
                                    ANukeCheck $CheckRealPath $CheckVirtualPath
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    iputs "'------------------------------------------------------------------------'"
    return 0
}

ANukeMain
