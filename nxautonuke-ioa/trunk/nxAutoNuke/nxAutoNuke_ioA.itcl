################################################################################
# nxAutoNuke - Auto-Nuke Banned, Empty, Incomplete, IMDB, and MP3 Releases     #
################################################################################
# Author  : neoxed                                                             #
# Date    : 01-31-2005                                                         #
# Version : 1.1.3 (rev 041)                                                    #
################################################################################

#### General ###############################################
#
# - User name to open for scheduled functions.
# - VFS file to mount for scheduled functions.
#
set misc(MountUser)     "sitebot"
set misc(MountFile)     "../etc/admin.vfs"

#### Time Settings #########################################
#
# - Use UTC time for dated directories, otherwise local time is used.
# - Use daylight savings time correction for UTC conversions.
# - The GMT time zone your site is in.
#
set misc(UTC_Time)      True
set misc(DST_Correct)   True
set misc(TimeZone)      -7

#### AutoNuke Settings #####################################
#
# - User and group to use for auto-nuking (must be valid!).
# - Nuke the whole release or only the violating sub-directory.
#
set anuke(UserName)     "ioFTPD"
set anuke(GroupName)    "ioFTPD"
set anuke(Release)      True
#
# - Bad and missing file extension (created by the zipscript).
# - Most zipscripts don't create .missing files for non-SFV releases (i.e. ZIPs);
#   we can overcome this problem, somewhat, by additionally checking for .bad files.
#
set anuke(BadExt)       "*.bad"
set anuke(MissingExt)   "*.missing"
#
# - Maximum age of directories to check (minutes).
# - Exempt certain releases from being checked (case insensitive).
# - Prefix for nuked releases (no wild-cards and case sensitive).
#
set anuke(MaximumAge)   1440
set anuke(Exempts)      {(incomplete)-* *dirfix* *dir[._]fix* *[._]fix[._]* *nfofix* *nfo[._]fix* *nfoupdate* *nfo[._]update* *samplefix* *sample[._]fix*}
set anuke(Prefix)       {[NUKED]-}
#
# - Display the uploaders for auto-nuke warning announcements.
# - Format of the uploaders list, cookies: %b = bold, %c = color, %u = underline, %(user), and %(group).
#
set anuke(WarnUsers)    True
set anuke(UserFormat)   "%b%(user)%b/%(group)"
set anuke(UserSplit)    ", "
#
# - The path to your ioA executable (ioA.exe).
#
set anuke(ioAPath)     "../scripts/ioA/ioA.exe"

#### AutoNuke Templates ####################################
#
# - Zipscript tag templates used for IMDB and MP3 checks.
# - Regular expression patterns are used to parse the tag data.
#
# - dZSbot IMDB: [IMDB] - Action (2004) - 2.7 of 10 - [IMDB]
# set anuke(ImdbMatch) {^\[IMDB\] - (.+) \((\d+)\) - ([\d\.]+) of 10 - \[IMDB\]$}
# set anuke(ImdbOrder) {genre year rating}
#
# - CalaZS MP3: [SITE] - ( 77.0MB 8F - COMPLETE - Death Metal 2004 ) - [SITE]
# set anuke(MP3Match) {^\[.*\] - \( .* - COMPLETE - (.+) (\d+) \) - \[.*\]$}
# set anuke(MP3Order) {genre year}
#
# - ioBanana IMDB: [4.0% Incomplete with 2F]-[imdbinfo - Action Adventure Animation Fantasy Family (2004) - 2.7 (520 votes)]
# set anuke(ImdbMatch) {^\[.*\]-\[imdbinfo - (.+) \((\d+)\) - ([\d\.]+) (.* votes)\]$}
# set anuke(ImdbOrder) {genre year rating}
#
# - ioBanana MP3: [100% Complete]-[8F @ 77.0MB at 4261Kbps]-[mp3info - Death Metal (2004) @ 256-kbps]
# set anuke(MP3Match) {^\[.*\]-\[.*\]-\[mp3info - (.+) \((\d+)\) @ .*\]$}
# set anuke(MP3Order) {genre year}
#
set anuke(ImdbMatch)    {^\[IMDB\] - (.+) \((\d+)\) - ([\d\.]+) of 10 - \[IMDB\]$}
set anuke(ImdbOrder)    {genre year rating}
set anuke(MP3Match)     {^\[.*\] - \( .* - COMPLETE - (.+) (\d+) \) - \[.*\]$}
set anuke(MP3Order)     {genre year}
#
# - The approve tag format, to exempt approved releases.
#
set anuke(ApproveTag)   {approved?by?*}

#### AutoNuke Reasons ######################################
#
# - General Cookies:
#   %(minutes)    - The remaining minutes until the release is nuked.
#
# - Special Cookies:
#   Allowed:
#     %(banned)   - The group's name which wasn't in the allow list.
#   Banned:
#     %(banned)   - The banned string which matched the release name.
#   Disks:
#     %(disks)    - Number of CDs/Disks the release had.
#     %(maxdisks) - The maximum number of disks allowed in that section.
#   IMDB:
#     %(type)     - The type of ban (genre/rating/year).
#     %(banned)   - The banned value (i.e. the release's genre, rating, or year).
#   MP3:
#     %(type)     - The type of ban (genre/year).
#     %(banned)   - The banned value (i.e. the release's genre or year).
#   Type:
#     %(banned)   - The banned keyword (bootleg, live, etc.).
#
set anuke(ReasonAllowed) "the.group.%(banned).is.not.allowed"
set anuke(ReasonBanned)  "banned.release.%(banned)"
set anuke(ReasonDisks)   "maximum.of.%(maxdisks).disks"
set anuke(ReasonEmpty)   "empty.after.%(minutes).minutes"
set anuke(ReasonImdb)    "banned.%(type).%(banned)"
set anuke(ReasonInc)     "incomplete.after.%(minutes).minutes"
set anuke(ReasonMP3)     "banned.%(type).%(banned)"
set anuke(ReasonType)    "banned.type.%(banned)"

#### AutoNuke Sections #####################################
#
# - Here you define the paths and type of auto-nuke checks to perform.
#   <virtual path> <day offset> {
#       {<check type>|<check settings>|<nuke multiplier>|<warn time>|<nuke time>}
#       ...
#   }
# - The 'virtual path' is the path to check, which may contain date cookies.
# - Available date cookies: %d - Day, %W - Week, %m - Month, %y - Year (04), %Y - Year with century (2004).
# - The 'day offset' is the offset of the current day (-1 for yesterday, 0 for today, 1 for tomorrow, etc.).
# - The 'warn time' and 'nuke time' are for how long to wait after the directory was created (in minutes).
#
# - Check Types:
#   allowed:
#     - Check for allowed release groups, nuke groups which are not allowed.
#     - Check settings: allowed groups, you may use wild-cards.
#   banned:
#     - Check for banned matches in the release name.
#     - Check settings: banned strings, you may use wild-cards.
#   disks:
#     - Enfore maximum number of disks per section (CDs, Disks, and DVDs).
#     - Check settings: max number of disks, anything larger then this will be nuked.
#   empty:
#     - Nuke empty releases or sub-directories, with no files.
#     - Check settings: not used for empty checks.
#   imdb:
#     - Nuke banned genres, low ratings, or unaccepted years.
#     - Check settings: genre:<banned genre> rating:<minimum rating> year:<allowed year>
#   incomplete:
#     - Nuke incomplete releases or sub-directories (checks for ".bad" or ".missing" files).
#     - Check settings: not used for incomplete checks.
#   mp3:
#     - Nuke banned genres or unaccepted years.
#     - Check settings: genre:<banned genre> year:<allowed year>
#   type:
#     - Check for banned keywords in the release name.
#     - Check settings: banned release keywords, no wild-cards.
#     - This works similar to the "banned" feature, but more efficiently for keywords.
#
set anuke(Sections) {
    "/0DAY/%m%d" 0 {
        {banned|*-A51 *-HS *-TiC *-YAG|10|0|0}
        {empty|Not-Used|3|20|40}
    }
    "/APPS" 0 {
        {disks|4|3|5|20}
        {empty|Not-Used|3|20|40}
        {incomplete|Not-Used|3|20|40}
    }
    "/GAMES" 0 {
        {empty|Not-Used|3|20|40}
        {incomplete|Not-Used|3|20|40}
    }
    "/MP3/%m%d" 0 {
        {incomplete|Not-Used|3|20|40}
        {empty|Not-Used|3|20|40}
        {mp3|genre:*rap* genre:*punk* year:200[0-6]|5|20|40}
        {type|cable dab demo dvb mixtape radio sample sat tape|3|20|40}
    }
    "/MP3/%m%d" -1 {
        {incomplete|Not-Used|3|20|40}
        {empty|Not-Used|3|20|40}
        {mp3|genre:*rap* genre:*punk* year:200[0-6]|5|20|40}
        {type|cable dab demo dvb mixtape radio sample sat tape|3|20|40}
    }
    "/SVCD" 0 {
        {disks|4|3|5|20}
        {empty|Not-Used|3|20|40}
        {imdb|genre:*documentary* genre:*romance* rating:5 year:200[2-6]|3|5|20}
        {incomplete|Not-Used|3|20|40}
    }
    "/VCD" 0 {
        {disks|3|3|5|20}
        {empty|Not-Used|3|20|40}
        {imdb|genre:*documentary* genre:*romance* rating:4 year:200[2-6]|3|5|20}
    }
    "/XXX" 0 {
        {allowed|LonelyWankers JackOffs MasterDebators|3|5|20}
        {disks|3|3|5|20}
        {empty|Not-Used|3|20|40}
    }
}

#### End of Settings #######################################

# Load Libraries
######################################################################

if {[catch {source [file join [file dirname [info script]] "nxLib.itcl"]} ErrorMsg]} {
    iputs "Error loading nxLib: $ErrorMsg"; return 1
}

# Nuke Procedures
######################################################################

proc ANukeIoA {RealPath VirtualPath Multi Reason} {
    global anuke
    ## Find credit and stats section
    foreach {CreditSection StatsSection} [GetCreditsAndStats $VirtualPath] {break}
    set RealPath [string map {/ \\} $RealPath]

    ## Borrowed this portion from Harm's ioAUTONUKE (since this ioA feature is undocumented)
    if {[catch {exec $anuke(ioAPath) NUKE $RealPath $VirtualPath $Multi $StatsSection $CreditSection $anuke(UserName) $anuke(GroupName) $Reason} OutputMsg]} {
        ErrorLog ANukeIoA "ioA Output:\n$Output"; return 0
    }
    foreach OutLine [split $OutputMsg "\r\n"] {
        if {![string first "NUKE:" $OutLine]} {putlog $OutLine}
    }
    return 1
}

proc ANukeName {VirtualPath} {
    set Release [file tail $VirtualPath]
    if {[IsMultiDisk $Release]} {
        set ParentPath [file tail [file dirname $VirtualPath]]
        if {![string equal "" $ParentPath]} {set Release "$ParentPath ($Release)"}
    }
    return $Release
}

# AutoNuke Procedures
######################################################################

proc ANukeAllowed {Patterns ReleaseName TargetValue} {
    upvar $TargetValue GroupName
    if {[set GroupPos [string last "-" $ReleaseName]] == -1} {return 0}
    set GroupName [string range $ReleaseName [incr GroupPos] end]
    foreach Pattern $Patterns {
        if {[string match -nocase $Pattern $GroupName]} {
            set BanValue $Pattern; return 0
        }
    }
    return 1
}

proc ANukeBanned {Patterns ReleaseName TargetValue} {
    upvar $TargetValue BanValue
    foreach Pattern $Patterns {
        if {[string match -nocase $Pattern $ReleaseName]} {
            set BanValue $Pattern; return 1
        }
    }
    return 0
}

proc ANukeEmpty {RealPath} {
    foreach FileName [glob -nocomplain -types f -directory $RealPath "*"] {
        if {![string equal -nocase -length 7 ".ioFTPD" [file tail $FileName]]} {return 0}
    }
    return 1
}

proc ANukeInc {RealPath} {
    global anuke
    foreach ListItem [glob -nocomplain -types f -directory $RealPath "*"] {
        set FileName [file tail $ListItem]
        if {[string match -nocase $anuke(BadExt) $FileName] || [string match -nocase $anuke(MissingExt) $FileName]} {return 1}
    }
    return 0
}

proc ANukeToList {CheckSettings} {
    set CheckList ""
    foreach ListItem $CheckSettings {
        foreach {Name Value} [split $ListItem ":"] {break}
        lappend CheckList [string tolower $Name] $Value
    }
    return $CheckList
}

proc ANukeIMDB {TagList CheckList TargetType TargetValue} {
    global anuke
    upvar $TargetType BanType $TargetValue BanValue

    set FoundMatch 0; set genre ""; set rating ""; set year ""
    foreach TagName $TagList {
        set ReMatch [regexp -inline -nocase -- $anuke(ImdbMatch) [file tail $TagName]]
        if {[llength $ReMatch]} {
            foreach $anuke(ImdbOrder) [lrange $ReMatch 1 end] {break}
            set FoundMatch 1; break
        }
    }
    if {!$FoundMatch} {return 0}

    foreach {BanType BanMatch} $CheckList {
        switch -exact -- $BanType {
            "genre" {
                if {[string match -nocase $BanMatch $genre]} {
                    set BanValue $genre; return 1
                }
            }
            "rating" {
                if {[string is double -strict $rating] && $rating < $BanMatch} {
                    set BanValue $rating; return 1
                }
            }
            "year" {
                if {$year != "" && ![string match -nocase $BanMatch $year]} {
                    set BanValue $year; return 1
                }
            }
        }
    }
    return 0
}

proc ANukeMP3 {TagList CheckList TargetType TargetValue} {
    global anuke
    upvar $TargetType BanType $TargetValue BanValue

    set FoundMatch 0; set genre ""; set year ""
    foreach TagName $TagList {
        set ReMatch [regexp -inline -nocase -- $anuke(MP3Match) [file tail $TagName]]
        if {[llength $ReMatch]} {
            foreach $anuke(MP3Order) [lrange $ReMatch 1 end] {break}
            set FoundMatch 1; break
        }
    }
    if {!$FoundMatch} {return 0}

    foreach {BanType BanMatch} $CheckList {
        switch -exact -- $BanType {
            "genre" {
                if {[string match -nocase $BanMatch $genre]} {
                    set BanValue $genre; return 1
                }
            }
            "year" {
                if {$year != "" && ![string match -nocase $BanMatch $year]} {
                    set BanValue $year; return 1
                }
            }
        }
    }
    return 0
}

proc ANukeType {TypeList ReleaseName TargetType} {
    upvar $TargetType BanType
    ## Remove the group name from the release
    if {[set GroupPos [string last "-" $ReleaseName]] != -1} {
        set ReleaseName [string range $ReleaseName 0 [incr GroupPos -1]]
    }
    set ReleaseSplit [string tolower [split $ReleaseName "()-._"]]

    ## Match types
    foreach TypeName $TypeList {
        if {[lsearch -exact $ReleaseSplit $TypeName] != -1} {
            set BanType $TypeName; return 1
        }
    }
	return 0
}

proc ANukeCheck {RealPath VirtualPath} {
    global anuke
    upvar check check NukedList NukedList WarnedList WarnedList

    ## Skip the release if it was already nuked
    set RealPathLow [string tolower $RealPath]
    if {[lsearch -exact $NukedList $RealPathLow] != -1} {return}
    set NukeSecs [expr {$check(NukeMins) * 60}]
    set WarnSecs [expr {$check(WarnMins) * 60}]

    if {$check(DirAge) >= $NukeSecs} {
        ## Nuke the release
        lappend check(CookieMap) %(minutes) $check(NukeMins)
        set check(Reason) [StripChars [string map $check(CookieMap) $check(Reason)]]

        if {[IsTrue $anuke(Release)] && [IsMultiDisk $VirtualPath]} {
            set RealPath [file dirname $RealPath]
            set VirtualPath [file dirname $VirtualPath]
        }

        LinePuts "Nuking: [ANukeName $VirtualPath] - $check(Reason)"
        if {![ANukeIoA $RealPath $VirtualPath $check(Multi) $check(Reason)]} {
            LinePuts "Encounted an error nuking the release, check nxError.log for details."
        }
        lappend NukedList $RealPathLow
    } elseif {$check(DirAge) >= $WarnSecs && [lsearch -exact $WarnedList $RealPathLow] == -1} {
        ## Obtain a list of nuked users
        if {[IsTrue $anuke(WarnUsers)]} {
            set UserList [ANukeUsers $RealPath]
        } else {
            set UserList "Disabled"
        }

        ## Log the warning
        lappend check(CookieMap) %(minutes) $check(WarnMins)
        set check(Reason) [StripChars [string map $check(CookieMap) $check(Reason)]]

        LinePuts "Warning: [ANukeName $VirtualPath] - $check(Reason)"
        set check(DirAge) [expr {$check(DirAge) / 60}]
        putlog "$check(WarningLog) \"$check(DirAge)\" \"[expr {$check(NukeMins) - $check(DirAge)}]\" \"$check(NukeMins)\" \"$check(Multi)\" \"$UserList\""
        lappend WarnedList $RealPathLow
    }
    return
}

proc ANukeFindTag {RealPath {TagTemplate "*"}} {
    set TagTemplate [string map {\[ \\\[ \] \\\] \{ \\\{ \} \\\}} $TagTemplate]
    return [glob -nocomplain -types d -directory $RealPath $TagTemplate]
}

proc ANukeUsers {RealPath} {
    global anuke
    GetDirList $RealPath dirlist ".ioFTPD*"
    foreach ListItem $dirlist(FileList) {
        if {[file size $ListItem] < 1} {continue}
        catch {vfs read $ListItem} VfsOwner
        ListAssign $VfsOwner UserID GroupID
        if {[set UserName [resolve uid $UserID]] != "" && ![info exists uploader($UserName)]} {
            set uploader($UserName) [GetGroupName $GroupID]
        }
    }
    ## Check if the release is an empty nuke
    if {[array names uploader] == ""} {
        catch {vfs read $RealPath} VfsOwner
        ListAssign $VfsOwner UserID GroupID
        if {[set UserName [resolve uid $UserID]] != ""} {
            set uploader($UserName) [GetGroupName $GroupID]
        } else {return ""}
    }
    ## Format uploaders list
    set FormatList ""
    foreach {UserName GroupName} [array get uploader] {
        set ReMap [list %b \002 %c \003 %u \031 %(user) $UserName %(group) $GroupName]
        lappend FormatList [string map $ReMap $anuke(UserFormat)]
    }
    return [join [lsort -ascii $FormatList] $anuke(UserSplit)]
}

# AutoNuke Main
######################################################################

proc ANukeMain {} {
    global anuke misc user group
    ## A userfile and VFS file will have to be opened so that resolve works under ioFTPD's scheduler
    if {![info exists user] && ![info exists group]} {
        if {[userfile open $misc(MountUser)] != 0} {
            ErrorLog AutoNuke "Error opening the user \"$misc(MountUser)\""; return 1
        } elseif {[mountfile open $misc(MountFile)] != 0} {
            ErrorLog AutoNuke "Error mounting the VFS-file \"$misc(MountFile)\""; return 1
        }
    }
    iputs ".-\[AutoNuke\]-------------------------------------------------------------."
    if {![file isfile $anuke(ioAPath)]} {
        ErrorLog AutoNuke "The file \"$anuke(ioAPath)\" does not exist."
        ErrorReturn "Invalid path to the ioA executable, check your configuration."
    }
    LinePuts "Checking [expr {[llength $anuke(Sections)] / 3}] auto-nuke sections."
    set NukedList ""; set WarnedList ""
    set anuke(ImdbOrder) [string tolower $anuke(ImdbOrder)]
    set anuke(MP3Order) [string tolower $anuke(MP3Order)]

    ## Timestamp used to format date cookies
    set TimeNow [clock seconds]
    if {[IsTrue $misc(UTC_Time)]} {set TimeNow [ToUTC $TimeNow $misc(TimeZone)]}
    set MaxAge [expr {$anuke(MaximumAge) * 60}]

    foreach {VirtualPath DayOffset NukeChecks} $anuke(Sections) {
        ## Convert date cookies
        set AreaTime [expr {$TimeNow + ($DayOffset * 86400)}]
        set VirtualPath [clock format $AreaTime -format $VirtualPath -gmt 0]
        LinePuts ""; LinePuts "Checking path: $VirtualPath (offset: $DayOffset)"
        set RealPath [resolve pwd $VirtualPath]
        if {![file isdirectory $RealPath]} {
            LinePuts "The directory does not exist, skipping."; continue
        }

        ## Check each auto-nuke type
        foreach ConfigLine $NukeChecks {
            if {[llength [set NukeCheck [split $ConfigLine "|"]]] != 5} {
                ErrorLog ANukeConfig "Wrong number of parameters in line: \"$ConfigLine\""; continue
            }
            foreach {CheckType CheckSettings check(Multi) check(WarnMins) check(NukeMins)} $NukeCheck {break}
            set TagType ""; set TagTemplate ""

            ## Validate auto-nuke type
            set CheckType [string tolower $CheckType]
            switch -exact -- $CheckType {
                "banned" - "type" {
                    set CheckSettings [string tolower $CheckSettings]
                }
                "imdb" - "mp3" {
                    set CheckSettings [ANukeToList $CheckSettings]
                }
                "allowed" - "disks" - "empty" - "inc" - "incomplete" {}
                default {
                    ErrorLog ANukeConfig "Invalid auto-nuke type \"$CheckType\" in line: \"$ConfigLine\""; continue
                }
            }
            set SingleDiskCheck [expr {[lsearch -exact "empty incomplete mp3" $CheckType] == -1}]

            foreach ReleasePath [glob -nocomplain -types d -directory $RealPath "*"] {
                set ReleaseName [file tail $ReleasePath]
                ## Remove exempted, old, and approved releases from the list
                if {![string first $anuke(Prefix) $ReleaseName] || [ListMatch $anuke(Exempts) $ReleaseName True] || [ANukeFindTag $ReleasePath $anuke(ApproveTag)] != "" || \
                    [catch {file stat $ReleasePath fstat}] || [set check(DirAge) [expr {[clock seconds] - $fstat(ctime)}]] > $MaxAge} {
                    continue
                }

                ## Find multi-disk directories
                set DoNuke 0; set CheckRealPaths ""; set ReMap ""
                foreach DiskDir [glob -nocomplain -types d -directory $ReleasePath "*"] {
                    if {[string first $anuke(Prefix) $ReleaseName] != 0 && [IsMultiDisk $DiskDir]} {
                        lappend CheckRealPaths $DiskDir
                    }
                }
                if {![llength $CheckRealPaths]} {lappend CheckRealPaths $ReleasePath}
                set CheckRealPath $ReleasePath
                set CheckVirtualPath [file join $VirtualPath $ReleaseName]

                if {$SingleDiskCheck} {
                    ## Release specific checks
                    switch -exact -- $CheckType {
                        "allowed" {
                            if {[ANukeAllowed $CheckSettings $ReleaseName BanMatch]} {
                                set check(Reason) $anuke(ReasonAllowed)
                                set check(CookieMap) [list %(banned) $BanMatch]
                                set check(WarningLog) "ANUKEALLOW: \"$CheckVirtualPath\" \"$BanMatch\""
                                ANukeCheck $CheckRealPath $CheckVirtualPath
                            }
                        }
                        "banned" {
                            if {[ANukeBanned $CheckSettings $ReleaseName BanMatch]} {
                                set check(Reason) $anuke(ReasonBanned)
                                set check(CookieMap) [list %(banned) $BanMatch]
                                set check(WarningLog) "ANUKEBAN: \"$CheckVirtualPath\" \"$BanMatch\""
                                ANukeCheck $CheckRealPath $CheckVirtualPath
                            }
                        }
                        "disks" {
                            if {[set DiskCount [llength $CheckRealPaths]] > $CheckSettings} {
                                set check(Reason) $anuke(ReasonDisks)
                                set check(CookieMap) [list %(disks) $DiskCount %(maxdisks) $CheckSettings]
                                set check(WarningLog) "ANUKECDS: \"$CheckVirtualPath\" \"$DiskCount\" \"$CheckSettings\""
                                ANukeCheck $CheckRealPath $CheckVirtualPath
                            }
                        }
                        "imdb" {
                            if {[set TagList [ANukeFindTag $CheckRealPath]] != "" && [ANukeIMDB $TagList $CheckSettings BanType BanValue]} {
                                set check(Reason) $anuke(ReasonImdb)
                                set check(CookieMap) [list %(type) $BanType %(banned) $BanValue]
                                set check(WarningLog) "ANUKEIMDB: \"$CheckVirtualPath\" \"$BanType\" \"$BanValue\""
                                ANukeCheck $CheckRealPath $CheckVirtualPath
                            }
                        }
                        "type" {
                            if {[ANukeType $CheckSettings $ReleaseName BanType]} {
                                set check(Reason) $anuke(ReasonType)
                                set check(CookieMap) [list %(banned) $BanType]
                                set check(WarningLog) "ANUKETYPE: \"$CheckVirtualPath\" \"$BanType\""
                                ANukeCheck $CheckRealPath $CheckVirtualPath
                            }
                        }
                    }
                } else {
                    ## Multi-disk specific checks
                    foreach CheckRealPath $CheckRealPaths {
                        if {[IsMultiDisk $CheckRealPath]} {
                            ## Find the age of the disk directory
                            if {[catch {file stat $CheckRealPath fstat}]} {continue}
                            set check(DirAge) [expr {[clock seconds] - $fstat(ctime)}]
                            set CheckVirtualPath [file join $VirtualPath $ReleaseName [file tail $CheckRealPath]]
                        }
                        switch -exact -- $CheckType {
                            "empty" {
                                if {[ANukeEmpty $CheckRealPath]} {
                                    set check(Reason) $anuke(ReasonEmpty)
                                    set check(CookieMap) ""
                                    set check(WarningLog) "ANUKEEMPTY: \"$CheckVirtualPath\""
                                    ANukeCheck $CheckRealPath $CheckVirtualPath
                                }
                            }
                            "inc" - "incomplete" {
                                if {[ANukeInc $CheckRealPath]} {
                                    set check(Reason) $anuke(ReasonInc)
                                    set check(CookieMap) ""
                                    set check(WarningLog) "ANUKEINC: \"$CheckVirtualPath\""
                                    ANukeCheck $CheckRealPath $CheckVirtualPath
                                }
                            }
                            "mp3" {
                                if {[set TagList [ANukeFindTag $CheckRealPath]] != "" && [ANukeMP3 $TagList $CheckSettings BanType BanValue]} {
                                    set check(Reason) $anuke(ReasonMP3)
                                    set check(CookieMap) [list %(type) $BanType %(banned) $BanValue]
                                    set check(WarningLog) "ANUKEMP3: \"$CheckVirtualPath\" \"$BanType\" \"$BanValue\""
                                    ANukeCheck $CheckRealPath $CheckVirtualPath
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    iputs "'------------------------------------------------------------------------'"
    return 0
}

ANukeMain
