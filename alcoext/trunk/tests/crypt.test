#
# AlcoExt - Alcoholicz Tcl extension.
# Copyright (c) 2005 Alcoholicz Scripting Team
#
# File Name:
#   crypt.test
#
# Author:
#   neoxed (neoxed@gmail.com) May 25, 2005
#
# Abstract:
#   Crypt command test suite.
#

package require tcltest 2
namespace import -force ::tcltest::*

if {$tcl_platform(platform) eq "windows"} {
    set libFile "AlcoExt*"
} else {
    set libFile "libAlcoExt*"
}
append libFile [info sharedlibextension]

set currentPath [file dirname [file normalize [info script]]]
set libFile [lindex [glob -dir [file dirname $currentPath] -types f $libFile] 0]
load $libFile

namespace import -force ::alcoholicz::*

# Source crypt test vectors.
source [file join $currentPath crypt-hash.tv]
source [file join $currentPath crypt-hmac.tv]
source [file join $currentPath crypt-cipher.tv]

# Algorithm definitions.
# algo    keyMin keyMax block rounds
set cipherList {
3des        24    24     8      16
aes         16    32     16     10
anubis      16    40     16     12
blowfish    8     56     8      16
cast5       5     16     8      16
des         8     8      8      16
khazad      16    16     8      8
noekeon     16    16     16     16
rc2         8     128    8      16
rc5         8     128    8      12
rc6         8     128    16     20
safer+      16    32     16     8
safer-k64   8     8      8      8
safer-sk64  8     8      8      8
safer-k128  16    16     8      8
safer-sk128 16    16     8      8
skipjack    10    10     8      32
twofish     16    32     16     16
xtea        16    16     8      32
}

set testData {
"\x32\xF8\x62\x06\xBB\x4E\x52\x5B\x32\xF8"
"\xD4\x41\x13\x20\x32\xBD\xAC\x67\x15\xF4\x45\x3C\xBC\x24\x34\xD8"
"\x6B\x6F\x32\xE5\xEA\xC2\xF4\x24\x07\x4C\x33\xF7\xC9\x88\xD5\xFE\x6B\x6F\x32\xE5\xEA\xC2\xF4\x24"
"\xB3\xE9\x5F\x51\x95\xBA\x64\x6D\xAF\x33\x3A\xA8\x91\x30\x45\x1F\xB3\xE9\x5F\x51\x95\xBA\x64\x6D\xAF\x33\x3A\xA8\x91\x30\x45\x1F"
"\x33\xC2\x62\xF5\x8B\xF0\xD9\x1D\xF2\x04\x7E\x79\x9B\xAA\x5F\x37\x33\xC2\x62\xF5\x8B\xF0\xD9\x1D\xF2\x04\x7E\x79\x9B\xAA\x5F\x37\x33\xC2\x62\xF5\x8B\xF0\xD9\x1D\xF2\x04\x7E\x79\x9B\xAA\x5F\x37\x33\xC2\x62\xF5\x8B\xF0\xD9\x1D\xF2\x04\x7E\x79\x9B\xAA\x5F\x37\x33\xC2\x62\xF5\x8B\xF0\xD9\x1D\xF2\x04\x7E\x79\x9B\xAA\x5F\x37\x33\xC2\x62\xF5\x8B\xF0\xD9\x1D\xF2\x04\x7E\x79\x9B\xAA\x5F\x37\x33\xC2\x62\xF5\x8B\xF0\xD9\x1D\xF2\x04\x7E\x79\x9B\xAA\x5F\x37\x33\xC2\x62\xF5\x8B\xF0\xD9\x1D\xF2\x04\x7E\x79\x9B\xAA\x5F\x37"
}

################################################################################
# crypt                                                                        #
################################################################################

test crypt-1.1 {crypt: no args} {
    list [catch {crypt} msg] $msg
} {1 {wrong # args: should be "crypt option arg ?arg ...?"}}

test crypt-1.2 {crypt: one arg} {
    list [catch {crypt .} msg] $msg
} {1 {bad option ".": must be decrypt, encrypt, end, hash, info, pkcs5, rand, start, or update}}

test crypt-1.3 {crypt: invalid option} {
    list [catch {crypt . a} msg] $msg
} {1 {bad option ".": must be decrypt, encrypt, end, hash, info, pkcs5, rand, start, or update}}

################################################################################
# crypt decrypt                                                                #
################################################################################

test crypt-2.1 {crypt decrypt: no args} {
    list [catch {crypt decrypt} msg] $msg
} {1 {wrong # args: should be "crypt decrypt ?switches? cipher key data"}}

test crypt-2.2 {crypt decrypt: ECB mode tests} {
    foreach algo [array names cipherTest] {
        set n 1
        foreach {key plain cipher} $cipherTest($algo) {
            set result [crypt decrypt $algo $key $cipher]

            if {$plain ne $result} {
                return "ECB $algo (vector $n):\n\
                    - key   =[encode hex $key]\n\
                    - cipher=[encode hex $cipher]\n\
                    - needed=[encode hex $plain]\n\
                    - result=[encode hex $result]"
            }
            incr n
        }
    }
} {}

################################################################################
# crypt encrypt                                                                #
################################################################################

test crypt-3.1 {crypt encrypt: no args} {
    list [catch {crypt encrypt} msg] $msg
} {1 {wrong # args: should be "crypt encrypt ?switches? cipher key data"}}

test crypt-3.2 {crypt decrypt: ECB mode tests} {
    foreach algo [array names cipherTest] {
        set n 1
        foreach {key plain cipher} $cipherTest($algo) {
            set result [crypt encrypt $algo $key $plain]

            if {$cipher ne $result} {
                return "ECB $algo (vector $n):\n\
                    - key   =[encode hex $key]\n\
                    - plain =[encode hex $plain]\n\
                    - needed=[encode hex $cipher]\n\
                    - result=[encode hex $result]"
            }
            incr n
        }
    }
} {}

test crypt-3.3 {crypt decrypt: more ECB mode tests} {
    foreach {algo minKey maxKey blockLength defRounds} $cipherList {
        set key [string repeat "ab" [expr {$maxKey / 2}]]

        set n 1
        foreach plain $testData {
            set length [string length $plain]
            set cipher [crypt encrypt -mode ecb $algo $key $plain]
            set result [crypt decrypt -mode ecb $algo $key $cipher]

            # Plain-text is padded to a multiple of a cipher's block-length in ECB mode.
            set result [string range $result 0 [incr length -1]]

            if {$plain ne $result} {
                return "ECB $algo (block-length $blockLength, vector $n):\n\
                    - key   =[encode hex $key]\n\
                    - plain =[encode hex $plain]\n\
                    - result=[encode hex $result]"
            }
            incr n
        }
    }
} {}

test crypt-3.4 {crypt decrypt: CBC mode tests} {
    foreach {algo minKey maxKey blockLength defRounds} $cipherList {
        set iv  [string repeat "\0" $blockLength]
        set key [string repeat "ab" [expr {$maxKey / 2}]]

        set n 1
        foreach plain $testData {
            set length [string length $plain]
            set cipher [crypt encrypt -iv $iv -mode cbc $algo $key $plain]
            set result [crypt decrypt -iv $iv -mode cbc $algo $key $cipher]

            # Plain-text is padded to a multiple of a cipher's block-length in CBC mode.
            set result [string range $result 0 [incr length -1]]

            if {$plain ne $result} {
                return "CBC $algo (block-length $blockLength, vector $n):\n\
                    - key   =[encode hex $key]\n\
                    - plain =[encode hex $plain]\n\
                    - result=[encode hex $result]"
            }
            incr n
        }
    }
} {}

test crypt-3.5 {crypt decrypt: CFB mode tests} {
    foreach {algo minKey maxKey blockLength defRounds} $cipherList {
        set iv  [string repeat "\0" $blockLength]
        set key [string repeat "ab" [expr {$maxKey / 2}]]

        set n 1
        foreach plain $testData {
            set cipher [crypt encrypt -iv $iv -mode cfb $algo $key $plain]
            set result [crypt decrypt -iv $iv -mode cfb $algo $key $cipher]

            if {$plain ne $result} {
                return "CFB $algo (block-length $blockLength, vector $n):\n\
                    - key   =[encode hex $key]\n\
                    - plain =[encode hex $plain]\n\
                    - result=[encode hex $result]"
            }
            incr n
        }
    }
} {}

test crypt-3.6 {crypt decrypt: CTR mode tests} {
    foreach {algo minKey maxKey blockLength defRounds} $cipherList {
        set iv  [string repeat "\0" $blockLength]
        set key [string repeat "ab" [expr {$maxKey / 2}]]

        set n 1
        foreach plain $testData {
            set cipher [crypt encrypt -iv $iv -mode ctr $algo $key $plain]
            set result [crypt decrypt -iv $iv -mode ctr $algo $key $cipher]

            if {$plain ne $result} {
                return "CTR $algo (block-length $blockLength, vector $n):\n\
                    - key   =[encode hex $key]\n\
                    - plain =[encode hex $plain]\n\
                    - result=[encode hex $result]"
            }
            incr n
        }
    }
} {}

test crypt-3.7 {crypt decrypt: OFB mode tests} {
    foreach {algo minKey maxKey blockLength defRounds} $cipherList {
        set iv  [string repeat "\0" $blockLength]
        set key [string repeat "ab" [expr {$maxKey / 2}]]

        set n 1
        foreach plain $testData {
            set cipher [crypt encrypt -iv $iv -mode ofb $algo $key $plain]
            set result [crypt decrypt -iv $iv -mode ofb $algo $key $cipher]

            if {$plain ne $result} {
                return "OFB $algo (block-length $blockLength, vector $n):\n\
                    - key   =[encode hex $key]\n\
                    - plain =[encode hex $plain]\n\
                    - result=[encode hex $result]"
            }
            incr n
        }
    }
} {}

################################################################################
# crypt hash                                                                   #
################################################################################

test crypt-4.1 {crypt hash: no args} {
    list [catch {crypt hash} msg] $msg
} {1 {wrong # args: should be "crypt hash ?-hmac key? hash data"}}

test crypt-4.2 {crypt hash: too many args} {
    list [catch {crypt hash a b c} msg] $msg
} {1 {wrong # args: should be "crypt hash ?-hmac key? hash data"}}

test crypt-4.3 {crypt hash: too many args} {
    list [catch {crypt hash -hmac a b c d} msg] $msg
} {1 {wrong # args: should be "crypt hash ?-hmac key? hash data"}}

test crypt-4.4 {crypt hash: invalid hash} {
    list [catch {crypt hash . a} msg] $msg
} {1 {bad hash ".": must be md2, md4, md5, rmd128, rmd160, sha1, sha224, sha256, sha384, sha512, tiger, or whirlpool}}

test crypt-4.5 {crypt hash: invalid hash, with -hmac} {
    list [catch {crypt hash -hmac a . b} msg] $msg
} {1 {bad hash ".": must be md2, md4, md5, rmd128, rmd160, sha1, sha224, sha256, sha384, sha512, tiger, or whirlpool}}

test crypt-4.5 {crypt hash: hash tests} {
    foreach algo [array names hashTest] {
        set n 1
        foreach {plain hash} $hashTest($algo) {
            set result [crypt hash $algo $plain]

            if {$hash ne $result} {
                return "hash $algo (vector $n):\n\
                    - plain =[encode hex $plain]\n\
                    - needed=[encode hex $hash]\n\
                    - result=[encode hex $result]"
            }
            incr n
        }
    }
} {}

test crypt-4.6 {crypt hash: hmac tests} {
    foreach algo [array names hmacTest] {
        set n 1
        foreach {key plain hash} $hmacTest($algo) {
            set result [crypt hash -hmac $key $algo $plain]

            if {$hash ne $result} {
                return "hmac $algo (vector $n):\n\
                    - key   =[encode hex $key]\n\
                    - plain =[encode hex $plain]\n\
                    - needed=[encode hex $hash]\n\
                    - result=[encode hex $result]"
            }
            incr n
        }
    }
} {}

################################################################################
# crypt start                                                                  #
################################################################################

test crypt-5.1 {crypt start: no args} {
    list [catch {crypt start} msg] $msg
} {1 {wrong # args: should be "crypt start ?-hmac key? hash"}}

test crypt-5.2 {crypt start: too many args} {
    list [catch {crypt start a b} msg] $msg
} {1 {wrong # args: should be "crypt start ?-hmac key? hash"}}

test crypt-5.3 {crypt start: too many args} {
    list [catch {crypt start -hmac a b c} msg] $msg
} {1 {wrong # args: should be "crypt start ?-hmac key? hash"}}

test crypt-5.4 {crypt start: invalid hash} {
    list [catch {crypt start .} msg] $msg
} {1 {bad hash ".": must be md2, md4, md5, rmd128, rmd160, sha1, sha224, sha256, sha384, sha512, tiger, or whirlpool}}

test crypt-5.5 {crypt start: invalid hash, with -hmac} {
    list [catch {crypt start -hmac a .} msg] $msg
} {1 {bad hash ".": must be md2, md4, md5, rmd128, rmd160, sha1, sha224, sha256, sha384, sha512, tiger, or whirlpool}}

test crypt-5.6 {crypt start: handle format} {
    -match regexp
    -body {
        set handle [crypt start md5]
        crypt end $handle
        set handle
    }
    -result {crypt\d+}
}

test crypt-5.7 {crypt start: check return} {
    set handlesBefore [crypt info handles]
    set handle [crypt start md5]
    set handlesAfter [crypt info handles]
    crypt end $handle
    list [expr {[lsearch -exact $handlesBefore $handle] != -1}] [expr {[lsearch -exact $handlesAfter $handle] != -1}]
} {0 1}

################################################################################
# crypt update                                                                 #
################################################################################

test crypt-6.1 {crypt update: no args} {
    list [catch {crypt update} msg] $msg
} {1 {wrong # args: should be "crypt update handle data"}}

test crypt-6.2 {crypt update: too many args} {
    list [catch {crypt update a b c} msg] $msg
} {1 {wrong # args: should be "crypt update handle data"}}

test crypt-6.3 {crypt update: invalid handle} {
    list [catch {crypt update . a} msg] $msg
} {1 {invalid crypt handle "."}}

test crypt-6.4 {crypt update: hash tests} {
    foreach algo [array names hashTest] {
        set n 1
        foreach {plain hash} $hashTest($algo) {
            set handle [crypt start $algo]
            crypt update $handle $plain
            set result [crypt end $handle]

            if {$hash ne $result} {
                return "hash $algo (vector $n):\n\
                    - plain =[encode hex $plain]\n\
                    - needed=[encode hex $hash]\n\
                    - result=[encode hex $result]"
            }
            incr n
        }
    }
} {}

test crypt-6.5 {crypt update: hmac tests} {
    foreach algo [array names hmacTest] {
        set n 1
        foreach {key plain hash} $hmacTest($algo) {
            set handle [crypt start -hmac $key $algo]
            crypt update $handle $plain
            set result [crypt end $handle]

            if {$hash ne $result} {
                return "hmac $algo (vector $n):\n\
                    - key   =[encode hex $key]\n\
                    - plain =[encode hex $plain]\n\
                    - needed=[encode hex $hash]\n\
                    - result=[encode hex $result]"
            }
            incr n
        }
    }
} {}

test crypt-6.6 {crypt update: hash tests, two updates} {
    foreach algo [array names hashTest] {
        set n 1
        foreach {plain hash} $hashTest($algo) {
            set handle [crypt start $algo]
            set index [expr {[string length $plain] / 2}]
            crypt update $handle [string range $plain 0 $index]
            crypt update $handle [string range $plain [incr index] end]
            set result [crypt end $handle]

            if {$hash ne $result} {
                return "hash $algo (vector $n):\n\
                    - plain =[encode hex $plain]\n\
                    - needed=[encode hex $hash]\n\
                    - result=[encode hex $result]"
            }
            incr n
        }
    }
} {}

test crypt-6.7 {crypt update: hmac tests, two updates} {
    foreach algo [array names hmacTest] {
        set n 1
        foreach {key plain hash} $hmacTest($algo) {
            set handle [crypt start -hmac $key $algo]
            set index [expr {[string length $plain] / 2}]
            crypt update $handle [string range $plain 0 $index]
            crypt update $handle [string range $plain [incr index] end]
            set result [crypt end $handle]

            if {$hash ne $result} {
                return "hmac $algo (vector $n):\n\
                    - key   =[encode hex $key]\n\
                    - plain =[encode hex $plain]\n\
                    - needed=[encode hex $hash]\n\
                    - result=[encode hex $result]"
            }
            incr n
        }
    }
} {}

################################################################################
# crypt end                                                                    #
################################################################################

test crypt-7.1 {crypt end: no args} {
    list [catch {crypt end} msg] $msg
} {1 {wrong # args: should be "crypt end handle"}}

test crypt-7.2 {crypt end: too many args} {
    list [catch {crypt end a b} msg] $msg
} {1 {wrong # args: should be "crypt end handle"}}

test crypt-7.3 {crypt end: invalid handle} {
    list [catch {crypt end .} msg] $msg
} {1 {invalid crypt handle "."}}

test crypt-7.4 {crypt end: check close} {
    set handlesStart [crypt info handles]
    set handle [crypt start md5]
    set handlesMiddle [crypt info handles]
    crypt end $handle
    set handlesEnd [crypt info handles]
    list [llength $handlesStart] [llength $handlesMiddle] [llength $handlesEnd]
} {0 1 0}

################################################################################
# crypt info                                                                   #
################################################################################

test crypt-8.1 {crypt info: no args} {
    list [catch {crypt info} msg] $msg
} {1 {wrong # args: should be "crypt info option"}}

test crypt-8.2 {crypt info: too many args} {
    list [catch {crypt info a b} msg] $msg
} {1 {wrong # args: should be "crypt info option"}}

test crypt-8.3 {crypt info: invalid option} {
    list [catch {crypt info .} msg] $msg
} {1 {bad option ".": must be ciphers, handles, hashes, or modes}}

test crypt-8.5 {crypt info: cipher count} {
    llength [crypt info ciphers]
} {19}

test crypt-8.4 {crypt info: ciphers must be in alphabetical order} {
    string equal [crypt info ciphers] [lsort [crypt info ciphers]]
} {1}

test crypt-8.6 {crypt info: handles} {
    llength [crypt info handles]
} {0}

test crypt-8.7 {crypt info: handles} {
    set handleOne [crypt start md5]
    set handleTwo [crypt start tiger]
    set handles [crypt info handles]
    crypt end $handleOne
    crypt end $handleTwo
    list [llength $handles] [llength [crypt info handles]]
} {2 0}

test crypt-8.8 {crypt info: hash count} {
    llength [crypt info hashes]
} {12}

test crypt-8.9 {crypt info: hashes must be in alphabetical order} {
    string equal [crypt info hashes] [lsort [crypt info hashes]]
} {1}

test crypt-8.10 {crypt info: mode list} {
    llength [crypt info modes]
} {5}

test crypt-8.11 {crypt info: modes must be in alphabetical order} {
    string equal [crypt info modes] [lsort [crypt info modes]]
} {1}

################################################################################
# crypt pkcs5                                                                  #
################################################################################

test crypt-9.1 {crypt pkcs5: no args} {
    list [catch {crypt pkcs5} msg] $msg
} {1 {wrong # args: should be "crypt pkcs5 ?-rounds count? hash salt password"}}

test crypt-9.2 {crypt pkcs5: too many args} {
    list [catch {crypt pkcs5 a b c d} msg] $msg
} {1 {wrong # args: should be "crypt pkcs5 ?-rounds count? hash salt password"}}

test crypt-9.3 {crypt pkcs5: too many args, with -rounds} {
    list [catch {crypt pkcs5 -rounds a b c d e} msg] $msg
} {1 {wrong # args: should be "crypt pkcs5 ?-rounds count? hash salt password"}}

test crypt-9.4 {crypt pkcs5: -rounds switch} {
    list [catch {crypt pkcs5 -rounds . a b c} msg] $msg
} {1 {expected integer but got "."}}

test crypt-9.5 {crypt pkcs5: -rounds switch} {
    list [catch {crypt pkcs5 -rounds -1 a b c} msg] $msg
} {1 {invalid round count "-1": must be 0 or greater}}

################################################################################
# crypt rand                                                                   #
################################################################################

test crypt-10.1 {crypt rand: no args} {
    list [catch {crypt rand} msg] $msg
} {1 {wrong # args: should be "crypt rand bytes"}}

test crypt-10.2 {crypt rand: too many args} {
    list [catch {crypt rand a b} msg] $msg
} {1 {wrong # args: should be "crypt rand bytes"}}

test crypt-10.3 {crypt rand: invalid byte count} {
    list [catch {crypt rand a} msg] $msg
} {1 {expected integer but got "a"}}

test crypt-10.4 {crypt rand: invalid byte count} {
    list [catch {crypt rand -1} msg] $msg
} {1 {invalid byte count "-1": must be greater than 0}}

test crypt-10.5 {crypt rand: invalid byte count} {
    list [catch {crypt rand 0} msg] $msg
} {1 {invalid byte count "0": must be greater than 0}}

test crypt-10.6 {crypt rand: retrieve 24 bytes} {
    string length [crypt rand 24]
} {24}

################################################################################
# crypt leak test                                                              #
################################################################################

test crypt-11.1 {crypt: leak test} {
    set handleList [list]
    # Ensure remaining crypt handles are freed during finalization.
    for {set i 0} {$i < 20} {incr i} {
        # These must not be closed!
        lappend handleList [crypt start md5]
    }
    list [llength $handleList] [llength [crypt info handles]]
} {20 20}

test crypt-11.2 {crypt: leak test, separate interp} {singleTestInterp} {
    set interp [interp create]
    interp eval $interp [list load $libFile]

    interp eval $interp {
        namespace import -force ::alcoholicz::*
        set handleList [list]

        for {set i 0} {$i < 20} {incr i} {
            # These must not be closed!
            lappend handleList [crypt start md5]
        }
        list [llength $handleList] [llength [crypt info handles]]
    }
} {20 20}


::tcltest::cleanupTests
return
